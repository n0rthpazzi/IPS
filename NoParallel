#include <iostream>
#include <math.h>
#include <iomanip>
#include <cmath>
#include <chrono>

using namespace std;
using namespace std::chrono;
typedef double(*pointFunc)(double);

double f (double x) {
    return (4/pow((1 + x * x) , 2));
}
double simpson_integral(pointFunc f, double a, double b, int n) {
    const double h = (b - a) / n;
    double k1 = 0, k2 = 0;
    for (int i = 1; i < n; i += 2) {
        k1 += f(a + i * h);
        k2 += f(a + (i + 1) * h);
    }
    return h / 3 * (f(a) + 4 * k1 + 2 * k2);
}
int main() {
    
    double a = -1, b = 1, eps;
    double s1, s;
    int n = 1;
    int i_nums; //начальное число шагов
    cout << "Input number of intervals = ";
    cin >> i_nums;
    eps = 1.0 / i_nums;
    high_resolution_clock::time_point t1 = high_resolution_clock::now();
    s1 = simpson_integral(f, a, b, n); //первое приближение для интеграла
    do{
        s = s1;     //второе приближение
        n = 2 * n;  //увеличение числа шагов в два раза,
                    //т.е. уменьшение значения шага в два раза
        s1 = simpson_integral(f, a, b, n);
    } while (fabs(s1 - s) > eps);  //сравнение приближений с заданной точностью
    high_resolution_clock::time_point t2 = high_resolution_clock::now();
    duration<double> duration = (t2 - t1);
    cout << "Duration is: " << duration.count() << " seconds" << endl;
    cout << "Integral = " << setprecision(10) << s1 << endl;
}
